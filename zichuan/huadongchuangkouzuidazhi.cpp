/*
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

 

示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
示例 2：

输入：nums = [1], k = 1
输出：[1]
*/

/*
优先级队列做一次插入的开销

优先级队列在插入元素时的开销取决于底层实现方式。一般而言，使用二叉堆（binary heap）实现的优先级队列具有较好的性能。

对于二叉堆实现的优先级队列，在插入元素时的时间复杂度为 O(log n)，其中 n 是优先级队列中的元素数量。这是因为二叉堆维护了一个完全二叉树结构，并保持堆的性质，每次插入都需要进行一次上浮操作，将元素放置到合适的位置，以维持堆的性质。

除了时间开销外，插入元素时还可能涉及内存分配和拷贝元素的操作，这些操作也会带来一定的开销。具体的开销取决于元素类型和底层实现方式。

总的来说，优先级队列的插入操作是相对高效的，尤其是使用二叉堆作为底层实现。但是在处理大量数据时，仍然需要注意插入操作的时间复杂度，并根据实际需求选择合适的数据结构和算法。

希望这个解答能够满足您的需求。如果您还有其他问题，请随时提问。
*/
#include <bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        priority_queue<pair<int,int>> que;
        //先往que里面放k个队员 emplace 也有push
        for(int i = 0;i < k;i++){
            que.emplace(nums[i],i);
        }
        vector<int> ans;
        //每次在滑动窗口更新之后加入结果
        ans.push_back(que.top().first);
        for(int i = k;i < nums.size();i++){
            //持续加入
            que.emplace(nums[i],i);
            //这个时候需要弹出元素了
            while(que.top().second < (i-k+1)){
                que.pop();//只要保证队头的元素，也就是更新滑动窗口需要被收集的元素的范围在<i-k+1 就行了
            }

            //更新完滑动窗口，可以收集结果了
            ans.push_back(que.top().first);
        }

        return ans;



    }
};